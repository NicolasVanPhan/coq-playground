<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>Table of contents</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<div id="toc">
<h2><a href="Chapter4.html">Library Chapter4</a></h2>
<ul class="doclist">
<li><a href="Chapter4.html#lab1">4.0 - Inductive Predicates</a>
<ul class="doclist">
<li><a href="Chapter4.html#lab2">Q: Recall definition of <span class="inlinecode"><span class="id" title="var">unit</span></span> and <span class="inlinecode"><span class="id" title="var">True</span></span>, and fundamental difference ?</a>

</li>
<li><a href="Chapter4.html#lab3">Q: Why not merging the two into 1 single type ?</a>

</li>
<li><a href="Chapter4.html#lab4">Q: Goal of this chapter ?</a>

</li>
</ul>

</li>
<li><a href="Chapter4.html#lab5">4.1 - Propositional Logic</a>
<ul class="doclist">
<li><a href="Chapter4.html#lab6">Q: How to avoid the boilerplate of dealing with and/or/not ?</a>

</li>
<li><a href="Chapter4.html#lab7">Q: What if <span class="inlinecode"><span class="id" title="tactic">tauto</span></span> fails because of some missing hypothesis ?</a>

</li>
<li><a href="Chapter4.html#lab8">Q: Common clean way to rewrite the above proof ?</a>

</li>
</ul>

</li>
<li><a href="Chapter4.html#lab9">4.5 - Recursive Predicates</a>
<ul class="doclist">
<li><a href="Chapter4.html#lab10">Q: Define <span class="inlinecode"><span class="id" title="var">even</span></span> and manually prove <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">0</span>, <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">4</span></a>

</li>
<li><a href="Chapter4.html#lab11">Q: Automate <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">4</span></a>

</li>
<li><a href="Chapter4.html#lab12">Q: prove <span class="inlinecode">¬<span class="id" title="var">even</span></span> <span class="inlinecode">1</span></a>

</li>
<li><a href="Chapter4.html#lab13">Q: Prove <span class="inlinecode">¬<span class="id" title="var">even</span></span> <span class="inlinecode">3</span>.</a>

</li>
<li><a href="Chapter4.html#lab14">Q: Prove <span class="inlinecode">¬<span class="id" title="var">even_plus</span></span>. Why not trivial ?</a>

</li>
<li><a href="Chapter4.html#lab15">Q: Lesson learned ? Proving <span class="inlinecode"><span class="id" title="var">even_plus</span></span>.</a>

</li>
<li><a href="Chapter4.html#lab16">Q: Now prove <span class="inlinecode">¬<span class="id" title="var">even</span></span> <span class="inlinecode">(2*<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1)</span></a>

</li>
<li><a href="Chapter4.html#lab17">Q: Lesson learned ? Proving <span class="inlinecode">¬<span class="id" title="var">even</span></span> <span class="inlinecode">(2<span class="id" title="var">n</span>+1)</span></a>

</li>
<li><a href="Chapter4.html#lab18">Q: What problem occurs when introducing variables to soon ?</a>

</li>
</ul>

</li>
</ul>
<h2><a href="Chapter5.html">Library Chapter5</a></h2>
<ul class="doclist">
<li><a href="Chapter5.html#lab19">5 - Infinite Data and Proofs</a>
<ul class="doclist">
<li><a href="Chapter5.html#lab20">Q: What will go wrong if we can define non-terminating functions ?</a>

</li>
<li><a href="Chapter5.html#lab21">Q: So how can we play with infinite lazy structures in Rocq ?</a>

</li>
</ul>

</li>
<li><a href="Chapter5.html#lab22">5.1 - Computing with Infinite Data</a>
<ul class="doclist">
<li><a href="Chapter5.html#lab23">Q: Define streams (infinite lists).</a>

</li>
<li><a href="Chapter5.html#lab24">Q: Define the stream of zeroes.</a>

</li>
<li><a href="Chapter5.html#lab25">Q: Define the stream of alternating true/false.</a>

</li>
<li><a href="Chapter5.html#lab26">Q: Write an <span class="inlinecode"><span class="id" title="var">approx</span></span> function to convert streams to lists.</a>

</li>
<li><a href="Chapter5.html#lab27">Q: Sanity-check your definitions with some examples.</a>

</li>
<li><a href="Chapter5.html#lab28">Q: Compare <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> and <span class="inlinecode"><span class="id" title="keyword">CoFixpoint</span></span>. Restrictions of both ?</a>

</li>
<li><a href="Chapter5.html#lab29">Q: Write a <span class="inlinecode"><span class="id" title="var">map</span></span> function over <span class="inlinecode"><span class="id" title="var">stream</span></span>s.</a>

</li>
<li><a href="Chapter5.html#lab30">Q: Example of classic function that does have its dual ?</a>

</li>
<li><a href="Chapter5.html#lab31">Q: More subtle example violating guardedness condition ?</a>

</li>
</ul>

</li>
<li><a href="Chapter5.html#lab32">5.2 - Infinite Proofs</a>
<ul class="doclist">
<li><a href="Chapter5.html#lab33">Q: Give example of 2 equal streams, and prove them equal.</a>

</li>
<li><a href="Chapter5.html#lab34">Q: APARTE : Print and explain the generated proof term <span class="inlinecode"><span class="id" title="var">stream_a_eq_b_try2</span></span></a>

</li>
<li><a href="Chapter5.html#lab35">Q: Proof v2 : Define a coinduction principle</a>

</li>
<li><a href="Chapter5.html#lab36">Q: APARTE : Illustrate the 'copy/paste' from <span class="inlinecode"><span class="id" title="var">stream_eq</span></span> to <span class="inlinecode"><span class="id" title="var">stream_eq_coind</span></span>.</a>

</li>
<li><a href="Chapter5.html#lab37">Q: Proof v3 : How to prove equality without defining any <span class="inlinecode"><span class="id" title="var">R</span></span> ?</a>

</li>
<li><a href="Chapter5.html#lab38">Q: Factorials : Define the stream of factorials</a>

</li>
<li><a href="Chapter5.html#lab39">Q: Factorials v1 : Prove them equal</a>

</li>
<li><a href="Chapter5.html#lab40">Q: Factorials v2 : Simpler proof of lemma</a>

</li>
</ul>

</li>
<li><a href="Chapter5.html#lab41">5.3 - Simple Modeling of non-terminating programs</a>
<ul class="doclist">
<li><a href="Chapter5.html#lab42">Q: Define a little language with :</a>

</li>
<li><a href="Chapter5.html#lab43">Q: Now, what object to define the evaluation of command, and why ?</a>

</li>
<li><a href="Chapter5.html#lab44">Q: Define a coinductive principle for the <span class="inlinecode"><span class="id" title="var">evalCmd</span></span> relation.</a>

</li>
<li><a href="Chapter5.html#lab45">Q: Now write a simple optimizing pass replacing <span class="inlinecode">0</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">e</span></span> with <span class="inlinecode"><span class="id" title="var">e</span></span>.</a>

</li>
<li><a href="Chapter5.html#lab46">Q: Prove <span class="inlinecode"><span class="id" title="var">optExp</span></span> correct.</a>

</li>
<li><a href="Chapter5.html#lab47">Q: BONUS: Prove <span class="inlinecode"><span class="id" title="var">optCmd</span></span> correct (left unexplained in the book).</a>

</li>
</ul>

</li>
</ul>
<h2><a href="Chapter6.html">Library Chapter6</a></h2>
<ul class="doclist">
<li><a href="Chapter6.html#lab48">6 - Subset Types and Variations</a>

</li>
<li><a href="Chapter6.html#lab49">6.1 - Introducing Subset Types</a>
<ul class="doclist">
<li><a href="Chapter6.html#lab50">Q: Define <span class="inlinecode"><span class="id" title="var">pred</span></span> and <span class="inlinecode"><span class="id" title="var">pred_strong</span></span>, asking for a proof of <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&gt;</span> <span class="inlinecode">0</span></a>

</li>
<li><a href="Chapter6.html#lab51">Q: Run <span class="inlinecode"><span class="id" title="var">pred_strong</span></span> with <span class="inlinecode">2</span> on the spot.</a>

</li>
<li><a href="Chapter6.html#lab52">Q: What if you introduce <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&gt;</span> <span class="inlinecode">0</span> early, next to <span class="inlinecode"><span class="id" title="var">n</span></span> ?</a>

</li>
<li><a href="Chapter6.html#lab53">Q: Re-implement <span class="inlinecode"><span class="id" title="var">pred_v2</span></span> with subset types ?</a>

</li>
<li><a href="Chapter6.html#lab54">Q: Why is the extracted Ocaml code with subset types ?</a>

</li>
<li><a href="Chapter6.html#lab55">Q: Now <span class="inlinecode"><span class="id" title="var">v3</span></span> - embed the proof that <span class="inlinecode"><span class="id" title="var">n'</span></span> is the pred of <span class="inlinecode"><span class="id" title="var">n</span></span> in the result type</a>

</li>
<li><a href="Chapter6.html#lab56">Q: Now <span class="inlinecode"><span class="id" title="var">v4</span></span> - Shorter version using tactic style</a>

</li>
<li><a href="Chapter6.html#lab57">Q: Finally <span class="inlinecode"><span class="id" title="var">v5</span></span> - Haskell style definition of <span class="inlinecode"><span class="id" title="var">pred</span></span></a>

</li>
</ul>

</li>
<li><a href="Chapter6.html#lab58">6.2 - Decidable Proposition Types</a>
<ul class="doclist">
<li><a href="Chapter6.html#lab59">Q: Define <span class="inlinecode"><span class="id" title="var">eq_nat_deciable</span></span> <span class="inlinecode">:</span> <span class="inlinecode">{<span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span>}</span> <span class="inlinecode">+</span> <span class="inlinecode">{<span class="id" title="var">n</span></span> <span class="inlinecode">≠</span> <span class="inlinecode"><span class="id" title="var">m</span>}</span></a>

</li>
<li><a href="Chapter6.html#lab60">Q: v2 with <span class="inlinecode"><span class="id" title="var">Yes</span></span>/<span class="inlinecode"><span class="id" title="var">No</span></span>/<span class="inlinecode"><span class="id" title="var">Reduce</span></span> notation</a>

</li>
<li><a href="Chapter6.html#lab61">Q: v3 in one line</a>

</li>
<li><a href="Chapter6.html#lab62">Q: Define <span class="inlinecode"><span class="id" title="var">In_decidable</span></span> with and without Yes/No/Reduce notation.</a>

</li>
</ul>

</li>
<li><a href="Chapter6.html#lab63">6.3 - Partial Subset Types</a>
<ul class="doclist">
<li><a href="Chapter6.html#lab64">Q: Define The <span class="inlinecode"><span class="id" title="var">maybe</span></span> type</a>

</li>
<li><a href="Chapter6.html#lab65">Q: v7 of <span class="inlinecode"><span class="id" title="var">pred</span></span>, using the <span class="inlinecode"><span class="id" title="var">maybe</span></span> notation.</a>

</li>
<li><a href="Chapter6.html#lab66">Q: Why is the <span class="inlinecode"><span class="id" title="var">maybe</span></span> type too loose for pred here ?</a>

</li>
<li><a href="Chapter6.html#lab67">Q: v8 of <span class="inlinecode"><span class="id" title="var">pred</span></span>, refusing dummy implementations.</a>

</li>
</ul>

</li>
<li><a href="Chapter6.html#lab68">6.4 - Monadic Notations</a>
<ul class="doclist">
<li><a href="Chapter6.html#lab69">Q: Write a version of <span class="inlinecode"><span class="id" title="var">double_pred</span></span> using <span class="inlinecode"><span class="id" title="var">maybe</span></span>.</a>

</li>
<li><a href="Chapter6.html#lab70">Q: Write a version of <span class="inlinecode"><span class="id" title="var">double_pred</span></span> using <span class="inlinecode"><span class="id" title="var">sumor</span></span>.</a>

</li>
</ul>

</li>
<li><a href="Chapter6.html#lab71">6.5 - A Type-Checking Example</a>

</li>
</ul>
<h2><a href="cpdt_notes.html">Library cpdt_notes</a></h2>
<ul class="doclist">
<li><a href="cpdt_notes.html#lab72">3.8 - Nested Inductive Types</a>
<ul class="doclist">
<li><a href="cpdt_notes.html#lab73">Q: Give an example of nested inductive type</a>

</li>
<li><a href="cpdt_notes.html#lab74">Q: Why is it called "nested" ?</a>

</li>
<li><a href="cpdt_notes.html#lab75">Q: What's the problem with it ?</a>

</li>
<li><a href="cpdt_notes.html#lab76">Q: Give an example of type definition violating the positivity rule</a>

</li>
<li><a href="cpdt_notes.html#lab77">Q: What is the usual problem with nested inductive types ?</a>

</li>
<li><a href="cpdt_notes.html#lab78">Q: Give the default generate induction principle</a>

</li>
<li><a href="cpdt_notes.html#lab79">Q:</a>

</li>
</ul>

</li>
<li><a href="cpdt_notes.html#lab80">3.9 - Manual Proofs about Constructors</a>

</li>
</ul>
<h2><a href="Extract.html">Library Extract</a></h2>
<h2><a href="Mycrush.html">Library Mycrush</a></h2>
<h2><a href="peano.html">Library peano</a></h2>
<h2><a href="scratch.html">Library scratch</a></h2>
</div>
<hr/>This page has been generated by <a href="http://rocq-prover.org/">coqdoc</a>
</div>

</div>

</body>
</html>