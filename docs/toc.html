<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>Table of contents</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<div id="toc">
<h2><a href="cpdt_notes.html">Library cpdt_notes</a></h2>
<ul class="doclist">
<li><a href="cpdt_notes.html#lab1">3.8 - Nested Inductive Types</a>
<ul class="doclist">
<li><a href="cpdt_notes.html#lab2">Q: Give an example of nested inductive type</a>

</li>
<li><a href="cpdt_notes.html#lab3">Q: Why is it called "nested" ?</a>

</li>
<li><a href="cpdt_notes.html#lab4">Q: What's the problem with it ?</a>

</li>
<li><a href="cpdt_notes.html#lab5">Q: Give an example of type definition violating the positivity rule</a>

</li>
<li><a href="cpdt_notes.html#lab6">Q: What is the usual problem with nested inductive types ?</a>

</li>
<li><a href="cpdt_notes.html#lab7">Q: Give the default generate induction principle</a>

</li>
<li><a href="cpdt_notes.html#lab8">Q:</a>

</li>
</ul>

</li>
<li><a href="cpdt_notes.html#lab9">3.9 - Manual Proofs about Constructors</a>

</li>
<li><a href="cpdt_notes.html#lab10">4.0 - Inductive Predicates</a>
<ul class="doclist">
<li><a href="cpdt_notes.html#lab11">Q: Recall definition of <span class="inlinecode"><span class="id" title="var">unit</span></span> and <span class="inlinecode"><span class="id" title="var">True</span></span>, and fundamental difference ?</a>

</li>
<li><a href="cpdt_notes.html#lab12">Q: Why not merging the two into 1 single type ?</a>

</li>
<li><a href="cpdt_notes.html#lab13">Q: Goal of this chapter ?</a>

</li>
</ul>

</li>
<li><a href="cpdt_notes.html#lab14">4.1 - Propositional Logic</a>
<ul class="doclist">
<li><a href="cpdt_notes.html#lab15">Q: How to avoid the boilerplate of dealing with and/or/not ?</a>

</li>
<li><a href="cpdt_notes.html#lab16">Q: What if <span class="inlinecode"><span class="id" title="tactic">tauto</span></span> fails because of some missing hypothesis ?</a>

</li>
<li><a href="cpdt_notes.html#lab17">Q: Common clean way to rewrite the above proof ?</a>

</li>
</ul>

</li>
<li><a href="cpdt_notes.html#lab18">4.5 - Recursive Predicates</a>
<ul class="doclist">
<li><a href="cpdt_notes.html#lab19">Q: Define <span class="inlinecode"><span class="id" title="var">even</span></span> and manually prove <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">0</span>, <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">4</span></a>

</li>
<li><a href="cpdt_notes.html#lab20">Q: Automate <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">4</span></a>

</li>
<li><a href="cpdt_notes.html#lab21">Q: prove <span class="inlinecode">¬<span class="id" title="var">even</span></span> <span class="inlinecode">1</span></a>

</li>
<li><a href="cpdt_notes.html#lab22">Q: Prove <span class="inlinecode">¬<span class="id" title="var">even</span></span> <span class="inlinecode">3</span>.</a>

</li>
<li><a href="cpdt_notes.html#lab23">Q: Prove <span class="inlinecode">¬<span class="id" title="var">even_plus</span></span>. Why not trivial ?</a>

</li>
<li><a href="cpdt_notes.html#lab24">Q: Lesson learned ? Proving <span class="inlinecode"><span class="id" title="var">even_plus</span></span>.</a>

</li>
<li><a href="cpdt_notes.html#lab25">Q: Now prove <span class="inlinecode">¬<span class="id" title="var">even</span></span> <span class="inlinecode">(2*<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1)</span></a>

</li>
<li><a href="cpdt_notes.html#lab26">Q: Lesson learned ? Proving <span class="inlinecode">¬<span class="id" title="var">even</span></span> <span class="inlinecode">(2<span class="id" title="var">n</span>+1)</span></a>

</li>
<li><a href="cpdt_notes.html#lab27">Q: What problem occurs when introducing variables to soon ?</a>

</li>
</ul>

</li>
<li><a href="cpdt_notes.html#lab28">5 - Infinite Data and Proofs</a>
<ul class="doclist">
<li><a href="cpdt_notes.html#lab29">Q: What will go wrong if we can define non-terminating functions ?</a>

</li>
<li><a href="cpdt_notes.html#lab30">Q: So how can we play with infinite lazy structures in Rocq ?</a>

</li>
</ul>

</li>
<li><a href="cpdt_notes.html#lab31">5.1 - Computing with Infinite Data</a>
<ul class="doclist">
<li><a href="cpdt_notes.html#lab32">Q: Define streams (infinite lists).</a>

</li>
<li><a href="cpdt_notes.html#lab33">Q: Define the stream of zeroes.</a>

</li>
<li><a href="cpdt_notes.html#lab34">Q: Define the stream of alternating true/false.</a>

</li>
<li><a href="cpdt_notes.html#lab35">Q: Write an <span class="inlinecode"><span class="id" title="var">approx</span></span> function to convert streams to lists.</a>

</li>
<li><a href="cpdt_notes.html#lab36">Q: Sanity-check your definitions with some examples.</a>

</li>
<li><a href="cpdt_notes.html#lab37">Q: Compare <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> and <span class="inlinecode"><span class="id" title="keyword">CoFixpoint</span></span>. Restrictions of both ?</a>

</li>
<li><a href="cpdt_notes.html#lab38">Q: Write a <span class="inlinecode"><span class="id" title="var">map</span></span> function over <span class="inlinecode"><span class="id" title="var">stream</span></span>s.</a>

</li>
<li><a href="cpdt_notes.html#lab39">Q: Example of classic function that does have its dual ?</a>

</li>
<li><a href="cpdt_notes.html#lab40">Q: More subtle example violating guardedness condition ?</a>

</li>
</ul>

</li>
</ul>
<h2><a href="peano.html">Library peano</a></h2>
</div>
<hr/>This page has been generated by <a href="http://rocq-prover.org/">coqdoc</a>
</div>

</div>

</body>
</html>